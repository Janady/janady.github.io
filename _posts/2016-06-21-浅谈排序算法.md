---
layout: post
title: 浅谈排序算法
date:   2016-06-20 03:37:29 +0800
categories: algorithms
---

> 最近对算法比较感兴趣，分治法的拆分、解决与合并，
递归的调用逻辑，动态规划背后的数学逻辑，搜索中的限制条件与边界等。
> 以及后面想聊聊的各种树结构，在构建、插入、搜索的表现。
>
> - 红黑树：平衡的搜索而叉树;
> - B树、B+树：更少的树高，减少磁盘时间; 
> - binary indexed tree: 数据与索引巧妙的关联等问题。
> - 哈希表：常数时间的寻址与内存消耗;

下面谈谈对各种排序问题的理解，主要从考虑的是效率问题，算法复杂度以及其常数时间。
针对以下排序：[冒泡排序](#bubble_sort)、[插入排序](#insertion_sort)、`合并排序`、`堆排序`以及`快速排序`。
就表现效果而言，`快排`的平均时间消耗最小，但最坏情况表现不好，在STL库中会切换为堆排序。`合并排序`, `堆排序`的最坏情况复杂度也为O(nlgn). 下面的排序都以从小到大的排序说明，主要考虑的是算法，也不涉及范型设计的类型的类型优化等问题。

## <span id = "bubble_sort">冒泡排序</span> ##

# 算法思想 #

对一个序列进行遍历，遍历中比较前一个数据，交换更大的数据到后面，一次遍历后序列尾指针前移，直到处理完所有数据。

```C++
// 示例区间是前闭后开, [begin, end)
Void bubble_sort(iterator begin, iterator end) {
    if (begin == end) return;
    while (begin+1 != end) {
        for (iterator it=begin+1; it!=end; it++) {
            if (*it < *(it-1)) swap(it, it-1);
            --end;
        }
    }
}
```

循环内部进行了比较，内存移动。比较操作容易打破处理器的处理流水线，平均占用较大时钟周期。内存移动频繁，也是个超出普通指令时间较多的操作。这里就不展开汇编代码，分析具体内循环平均占用的指令周期数。
> 
> 时间公式是：`T(n) = T(n-1) + c(n-1); `
> 
> 展开得时间复杂度为n<sup>2</sup>，此处的c与后面的插入时间作比较。

## <span id = "insertion_sort">插入排序</span> ##

# 算法思想 #

插入排序也是以双层循环的形式进行，每次遍历插入一个数据到已完成的有序序列中。

```C++
Void insertion_sort(iterator begin, iterator end) {
    if (begin == end) return;
    for (iterator i=(begin+1); i!=end; i++) {
        // insert val[i] to sorted array [begin, i).
        T value = *i; // value type T, 此处省去传参或提取类型
        for (iterator it=begin; it<i; ++it) {
            if (*it >= value) {
                /* 从后往前进行内存复制 */
                copy_backward(it, i, i+1);
                *it = value;
                break;
            }
        }
    }
}
```

从结构的角度看，插入排序与冒泡排序很相似，也有着相同的复杂度O(n<sup>2</sup>)。

但常数时间上，插入排序优于冒泡排序。可以从`比较`和`优化`两个方面分析一下：

>
> **比较** 冒泡排序的有序空间在末尾，而遍历的每个过程都需要比较，而插入排序的有序空间在前面，在等概率分布的模型中，可以节省一半的比较次数。
>
> **优化** 循环中的判断流严重影响循环展开与指令预测，在插入排序中可以考虑更多的内存移动方式，减少不必要的分支判断。（此处略过优化细节）

## 合并排序 ##
待续......

